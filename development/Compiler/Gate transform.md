---
layout: default
---
[Infer.NET development](../index.md) : [Compiler transforms](../Compiler transforms.md)

## Gate transform

The purpose of the gate transform is to remove conditional statements in MSL, by replacing them with equivalent code involving duplicated variables. (In fact, some if statements will remain but these are of a special form, and only used to indicate to the MessagePassingTransform that an evidence message is needed.)
 
There are 3 kinds of conditional statement allowed in MSL:

1.  `if` statement whose condition is a boolean variable or the complement of a boolean variable.
2.  `if` statement whose condition is of the form `(x==value)` where `value` is a literal boolean or integer and `x` is a variable or array element. There must be a separate `if` for each value. This is generated by Variable.Case and abbreviated as a `case` statement.
3.  `if` statement whose condition is of the form `(x==i)` where `i` is a loop counter ranging over all values of `x`, `x` is an integer variable or array element, and `x` is initialized outside the loop. This is generated by Variable.Switch and abbreviated as a `switch` statement.

For each of these, the transform does the following:

1.  The condition variable is split into multiple boolean variables, one for each case. These are stored in an array called c_cases which is initialized by `Gate.Cases`. The c_cases array is given the `DoNotSendEvidence` attribute.
2.  Each statement inside the body is wrapped by a new `if` on one of the case variables above. If the statement to be wrapped is a `for` loop, the wrapping happens to its body (as if the loop were unrolled). After the transform, these wrapped `if`s are all that remains from the original conditional. In particular, there will be no more `case` or `switch` statements.
3.  Enter variable = A random variable that is used inside the conditional but initialized outside the conditional. An enter variable is split by the transform into multiple clones, one for each case. The clones are initialized by `Gate.Enter`, `Gate.EnterPartial`, or `Gate.EnterOne` as appropriate. `Gate.Enter` creates a clone for every case. `Gate.EnterPartial` creates a clone for a subset of cases, for example, if the variable is used in the `else` clause only. `Gate.EnterOne` creates one clone only, for situations when the compiler can easily determine that the variable must be used in exactly one case.
4.  Exit variable = A random variable that is initialized inside the conditional and subsequently used outside the conditional. An exit variable is first defined in terms of separate clones, one inside each case. Then the clones are merged by `Gate.Exit`.

The reason for the variable cloning process is to ensure that no case of the conditional refers to a variable outside of that case. Otherwise it would let information travel freely outside of the case. We don't want information to travel outside that case unless the case is switched on, and we don't know that until we perform inference. Also, we don't want information flowing between mutually exclusive cases of the same conditional. So we use Enter/Exit factors to control the flow of information.
 
The implementation of `GateTransform`:

*   GateAnalysisTransform attaches a GateBlock attribute to all condition statements. A GateBlock attribute describes all external variables used or defined inside the block. For arrays, we need to group uses of an array into disjoint sets of indices, so that each use is covered by one of the sets. Each use is described by an indexing pattern and a set of bindings (assignments to condition variables).

*   ConvertCondition parses the condition expression and checks if a ConditionInformation already exists for the condition variable. If not, a ConditionInformation object is created and code to define the cases array is inserted into the output (see ConditionInformation.Build). ConvertCondition calls ConvertConditionCase to convert the Then and Else bodies. If the condition is deterministic, then there is no need to collect evidence so instead of wrapping each statement, the entire converted block is wrapped with the condition.

*   ConvertConditionCase wraps all statements in the block with conditionals for the purpose of collecting evidence. 

*   ConvertVariableDecl attaches the current ConditionInformation as an attribute to the declaration. Any variable with this attribute is a local variable of the condition.

*   ConvertVariableRefExpr and ConvertArrayIndexer call ReplaceWithClone.

*   ReplaceWithClone checks if the expression contains a reference to a stochastic non-local variable. If so, it calls GetClone.

*   ConditionInformation.GetClone fetches a ClonedVarInfo from the CondInfo.cloneMap, or creates one if needed. When creating a clone, the new declaration is placed in a sufficient set of containers. That is, if the expression being cloned refers to a local variable of a container, then the clone must be declared inside that container. CloneVarInfo.GetCloneForCase returns the new expression.

*   ConditionInformation.CreateCloneArray makes code to define the clone array and adds it outside the condition statement. This code is wrapped with a condition constructed from the bindings where this variable is used.

*   CloneVarInfo.GetCloneForCase makes code to extract an element of the clone array and adds it inside the condition statement. This new variable must send evidence to the cases array, so the new code is placed inside the condition statement.

Examples follow.

**If statement**

| Input | Output | 
|----------------|
| `if(c) {`<br />`bool b = Factor.Bernoulli(0.1);``Constrain.True(b);`<br />`}`| `bool[] c_cases = new bool[2];`<br />`c_cases = Gate.Cases(c);`<br />`if(c_cases[0]) {`<br />`bool b = Factor.Bernoulli(0.1);`<br />`Constrain.True(b);`<br />`}`|
| `if(c) {`<br /> `Constrain.EqualRandom(x, constDist);`<br /> `}`| `bool[] c_cases = new bool[2];`<br /> `c_cases = Gate.Cases(c);`<br /> <br /> `bool[] x_cond_c = new bool[1];`<br /> `x_cond_c = Gate.EnterPartial(c_cases, x, 0);`<br /> <br /> `if(c_cases[0]) {`<br /> `Constrain.EqualRandom(x_cond_c[0], constDist);`<br /> `}`|
| `if(c) {`<br /> `double sum = Factor.Sum(array);`<br /> `}`| `bool[] c_cases = new bool[2];`<br /> `c_cases = Gate.Cases(c);`<br /> <br /> `bool[][] array_cond_c = new bool[1][];`<br /> `for(int _gateind = 0; _gateind < 1; _gateind++) {`<br /> `array_cond_c[_gateind] = new bool[3];`<br /> `}`<br /> `array_cond_c = Gate.EnterPartial(c_cases, array, 0);`<br /> <br /> `if(c_cases[0]) {`<br /> `double sum = Factor.Sum(array_cond_c[0]);`<br /> `}`|
| `for(int i = 0; i < 3; i++) {`<br /> `if(c[i]) {`<br /> `bool b = Factor.Bernoulli(0.1);`<br /> `Constrain.True(b);`<br /> `}`<br /> `}`| `for(int i = 0; i < 3; i++) {`<br /> `bool[] c_i_cases = new bool[2];`<br /> `c_i_cases = Gate.Cases(c[i]);`<br /> `if(c_i_cases[0]) {`<br /> `bool b = Factor.Bernoulli(0.1);`<br /> `Constrain.True(b);`<br /> `}`<br /> `}`|
| `for(int i = 0; i < 3; i++) {`<br /> `if(c[i]) {`<br /> `Constrain.EqualRandom(array[i], constDist);`<br /> `}`<br /> `}`| `for(int i = 0; i < 3; i++) {`<br /> `bool[] c_i_cases = new bool[2];`<br /> `c_i_cases = Gate.Cases(c[i]);`<br /> `bool[] array_i_cond_c = new bool[1];`<br /> <br /> `array_i_cond_c = Gate.EnterPartial(c_i_cases, array[i], 0);`<br /> `if(c_i_cases[0]) {`<br /> `Constrain.EqualRandom(array_i_cond_c[0], constDist);`<br /> `}`<br /> `}`|
| `if(c) {`<br /> `for(int i = 0; i < 3; i++) {`<br /> `Constrain.EqualRandom(array[i], constDist);`<br /> `}`<br /> `}`| `bool[] c_cases = new bool[2];`<br /> `c_cases = Gate.Cases(c);`<br /> `for(int i = 0; i < 3; i++) {`<br /> `bool[] array_i_cond_c = new bool[1];`<br /> `array_i_cond_c = Gate.EnterPartial(c_cases, array[i], 0);`<br /> `if(c_cases[0]) {`<br /> `Constrain.EqualRandom(array_i_cond_c[0], constDist);`<br /> `}`<br /> `}`|
| `if(c) {`<br /> `for(int k = 0; k < 2; k++) {`<br /> `for(int i = 0; i < 3; i++) {`<br /> `Constrain.EqualRandom(array[i], constDist);`<br /> `}`<br /> `}`<br /> `}`| `bool[] c_cases = new bool[2];`<br /> `c_cases = Gate.Cases(c);`<br /> `for(int i = 0; i < 3; i++) {`<br /> `bool[] array_i_cond_c = new bool[1];`<br /> `array_i_cond_c = Gate.EnterPartial(c_cases, array[i], 0);`<br /> `}`<br /> `for(int k = 0; k < 2; k++) {`<br /> `for(int i = 0; i < 3; i++) {`<br /> `// re-enter non-nested container`<br /> `if(c_cases[0]) {`<br /> `Constrain.EqualRandom(array_i_cond_c[0], constDist);`<br /> `}`<br /> `}`<br /> `}`|
| `for(int j = 0; j < 2; j++) {`<br /> `if(c[j]) {`<br /> `for(int i = 0; i < 3; i++) {`<br /> `Constrain.EqualRandom(array[i][j], constDist);`<br /> `}`<br /> `}`<br /> `}`| `for(int j = 0; j < 2; j++) {`<br /> `bool[] c_j_cases = new bool[2];`<br /> `c_j_cases = Gate.Cases(c[j]);`<br /> `for(int i = 0; i < 3; i++) {`<br /> `bool[] array_i_j_cond_c_j = new bool[1];`<br /> `array_i_j_cond_c_j = Gate.EnterPartial(c_j_cases, array[i][j], 0);`<br /> `if(c_j_cases[0]) {`<br /> `Constrain.EqualRandom(array_i_j_cond_c_j[0], constDist);`<br /> `}`<br /> `}`<br /> `}`|

**Exit variable example**

| | |
|---|
| `bool x;`<br /> `if(c) {`<br /> `x = Factor.Bernoulli(p);`<br /> `Constrain.EqualRandom(x, constDist);`<br /> `} else {`<br /> `x = Factor.Bernoulli(q);`<br /> `}`| `bool x;`<br /> `bool[] c_cases = new bool[2];`<br /> `c_cases = Gate.Cases(c);`<br /> <br /> `bool[] x_cond_c = new bool[2];`<br /> `if(c_cases[0]) {`<br /> `x_cond_c[0] = Factor.Bernoulli(p);`<br /> `Constrain.EqualRandom(x_cond_c[0], constDist);`<br /> `}`<br /> `if(c_cases[1]) {`<br /> `x_cond_c[1] = Factor.Bernoulli(q);`<br /> `}`<br /> `x = Gate.Exit(c_cases, x_cond_c);`|

Alternative method:

| | |
|---|
| `if(c) {`<br /> `for(int i = 0; i < 3; i++) {`<br /> `Constrain.EqualRandom(array[i], constDist);`<br /> `}`<br /> `}`| `bool[] c_cases = new bool[2];`<br /> `c_cases = Gate.Cases(c);`<br /> `bool[][] array_cond_c = new bool[1][];`<br /> `for(int _gateind = 0; _gateind < 1; _gateind++) {`<br /> `array_cond_c[_gateind] = new bool[3];`<br /> `}`<br /> `array_cond_c = Gate.EnterPartial(c_cases, array, 0);`<br /> `for(int i = 0; i < 3; i++) {`<br /> `if(c_cases[0]) {`<br /> `Constrain.EqualRandom(array_cond_c[0][i], constDist);`<br /> `}`<br /> `}`|

**Case statement**

| Input | Output |
|----------------|
| `if(i==0) {`<br /> `bool b = Factor.Bernoulli(0.1);`<br /> `Constrain.True(b);`<br /> `}`<br /> `if(i==1) {`<br /> `Constrain.EqualRandom(x, constDist);`<br /> `}`<br /> `if(i==2) {`<br /> `Constrain.EqualRandom(array[i], constDist);`<br /> `}`| `bool[] i_cases = new bool[3];`<br /> `i_cases = Gate.Cases(i);`<br /> <br /> `if(i_cases[0]) {`<br /> `bool b = Factor.Bernoulli(0.1);`<br /> `Constrain.True(b);`<br /> `}`<br /> <br /> `bool[] x_cond_i = new bool[1];`<br /> `x_cond_i = Gate.EnterPartial(i_cases, x, 1);`<br /> `if(i_cases[1]) {`<br /> `Constrain.EqualRandom(x_cond_i[0], constDist);`<br /> `}`<br /> <br /> `bool array_2_cond_i;`<br /> `array_i_cond_i = Gate.EnterOne(i_cases, array[2], 2);`<br /> `if(i_cases[2]) {`<br /> `Constrain.EqualRandom(array_2_cond_i, constDist);`<br /> `}`|

**Switch statement**

| Input | Output |
|----------------|
| `for(int j = 0; j < 3; j++) {`<br /> `if(i==j) {`<br /> `bool b = Factor.Bernoulli(0.1);`<br /> `Constrain.True(b);`<br /> `}`<br /> `}`| `bool[] i_cases = new bool[3];`<br /> `i_cases = Gate.Cases(i);`<br /> `for(int j = 0; j < 3; j++) {`<br /> `if(i_cases[j]) {`<br /> `bool b = Factor.Bernoulli(0.1);`<br /> `Constrain.True(b);`<br /> `}`<br /> `}`|
| `bool b = Factor.Bernoulli(0.1);`<br /> `for(int j = 0; j < 3; j++) {`<br /> `if(i==j) {`<br /> `Constrain.True(b);`<br /> `}`<br /> `}`| `bool[] i_cases = new bool[3];`<br /> `i_cases = Gate.Cases(i);`<br /> `bool[] b_cond_i = new bool[3];`<br /> `b_cond_i = Gate.Enter(i_cases, b);`<br /> `for(int j = 0; j < 3; j++) {`<br /> `if(i_cases[j]) {`<br /> `// Make a copy to ensure only one use of b_cond_i[j]`<br /> `bool b_cond_i_j = Factor.Copy(b_cond_i[j]);`<br /> `Constrain.True(b_cond_i_j);`<br /> `}`<br /> `}`|
| `for(int j = 0; j < 3; j++) {`<br /> `if(i==j) {`<br /> `Constrain.EqualRandom(x[i], constDist);`<br /> `}`<br /> `}`| `bool[] i_cases = new bool[3];`<br /> `i_cases = Gate.Cases(i);`<br /> `for(int j = 0; j < 3; j++) {`<br /> `if(i_cases[j]) {`<br /> `bool x_i_cond_i = Gate.EnterOne(i_cases, x[j], j);`<br /> `Constrain.EqualRandom(x_i_cond_i, constDist);`<br /> `}`<br /> `}`|
| `bool x;`<br /> `for(int j = 0; j < 3; j++) {`<br /> `if(i==j) {`<br /> `x = Factor.Bernoulli(const[i]);`<br /> `Constrain.EqualRandom(x, constDist[i]);`<br /> `}`<br /> `}`| `bool x;`<br /> `bool[] i_cases = new bool[3];`<br /> `i_cases = Gate.Cases(i);`<br /> `bool[] x_cond_i = new bool[3];`<br /> `for(int j = 0; j < 3; j++) {`<br /> `if(i_cases[j]) {`<br /> `bool x_cond_i_j = Factor.Bernoulli(const[j]);`<br /> `x_cond_i[j] = Factor.Copy(x_cond_i_j);`<br /> `Constrain.EqualRandom(x_cond_i_j, constDist[j]);`<br /> `}`<br /> `}`<br /> `x = Gate.Exit(i_cases, x_cond_i);`|

